<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ecstaticmorse</title><link>http://ecstaticmorse.net/</link><description>ecstaticmorse</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 25 Mar 2021 16:37:41 -0700</lastBuildDate><atom:link href="http://ecstaticmorse.net/index.xml" rel="self" type="application/rss+xml"/><item><title>Polonius and the Secret of the Eliminated Quantifier</title><link>http://ecstaticmorse.net/posts/quantifier-elimination/</link><pubDate>Thu, 25 Mar 2021 16:37:41 -0700</pubDate><guid>http://ecstaticmorse.net/posts/quantifier-elimination/</guid><description>&lt;p>I&amp;rsquo;ve long been intrigued by &lt;a href="https://github.com/rust-lang/polonius">Polonius&lt;/a>, an improved formulation of the borrow
checker inspired by more traditional alias analyses.
The algorithm that became Polonius was first described by Niko Matsakis in &lt;a href="http://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker">&amp;ldquo;An
alias-based formulation of the borrow checker&amp;rdquo;&lt;/a>, and has since
been implemented &lt;a href="https://github.com/rust-lang/polonius">out-of-tree&lt;/a>.&lt;/p>
&lt;p>The project is currently on hiatus, however, and resumption does not seem
imminent. One roadblock is Polonius' inability to reason about &lt;a href="https://doc.rust-lang.org/nomicon/hrtb.html">higher-rank
trait bounds (HRTBs)&lt;/a>. It&amp;rsquo;s pretty rare for users to encounter
these, but they&amp;rsquo;re an integral part of the language that appear when desugaring
some &lt;code>Fn&lt;/code> trait bounds. This shortcoming was &lt;a href="https://smallcultfollowing.com/babysteps/blog/2019/01/21/hereditary-harrop-region-constraints/">described in detail&lt;/a> on
Niko&amp;rsquo;s blog over 2 years ago in his last post on Polonius. I suggest reading
that post&amp;rsquo;s immediate predecessor, &lt;a href="https://smallcultfollowing.com/babysteps/blog/2019/01/17/polonius-and-region-errors/">a more general discussion of placeholder
region errors&lt;/a>, as well.&lt;/p>
&lt;p>As far as I know, there is no accepted solution to these problems. This post
will explore one possibility, an algorithm for quantifier elimination in a
fragment of first-order logic on partially ordered sets. The idea (if not the
nomenclature) is pretty simple, but I haven&amp;rsquo;t seen it discussed in any of the
usual forums.&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> This is somewhat surprising, since it appears to solve
the problems around HRTBs in a straightforward manner.&lt;/p>
&lt;h2 id="quantifier-elimination">Quantifier elimination&lt;/h2>
&lt;p>In formal logic, the process of rewriting a formula that includes quantifiers
into an equivalent one without them is known as &lt;a href="https://mathworld.wolfram.com/QuantifierElimination.html">quantifier elimination&lt;/a>
(QE). Certain theories are said to have QE, which means that all formulas can
be rewritten this way, while others do not. For example, the real numbers with
addition, multiplication, equality, and strict ordering have QE,&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> but not
the integers with the same operators. If you disallow multiplication between
integer variables, however, you get &lt;a href="https://en.wikipedia.org/wiki/Presburger_arithmetic">Presburger arithmetic&lt;/a>, which &lt;em>does&lt;/em>
allow for QE.&lt;/p>
&lt;p>Our goal, then, is to find a QE algorithm for the &amp;ldquo;theory&amp;rdquo; of placeholder
regions used by Polonius. Clearly, this will depend on both the domain of our
theory (regions), as well as the operations allowed on those regions.&lt;/p>
&lt;h2 id="regions-are-sets-of-loans">Regions are sets of loans&lt;/h2>
&lt;p>Niko&amp;rsquo;s blog posts lay out the requirements for Polonius' placeholder region
logic. As he explains it, &amp;ldquo;regions are sets of loans&amp;rdquo;, so our domain is that of
sets. Placeholder regions are somewhat different than the sets of loans that
appear when checking function bodies. Inside a function, there is a finite
number of loans, each corresponding to a borrow (&lt;code>&amp;amp;&lt;/code> or &lt;code>&amp;amp;mut&lt;/code>) in the source.
However, placeholder regions are more abstract in some sense; relationships
between placeholder regions in a function signature subset relationships must
hold for all possible callers of that function. Therefore, we will treat
placeholder regions as if they may contain infinitely many loans,
the set of all possible loans that can be created in all possible Rust
programs.&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Sets, when ordered by inclusion, are an example of a common algebraic structure
called a &lt;a href="https://en.wikipedia.org/wiki/Partially_ordered_set">partially-ordered set or poset&lt;/a>. If we extend our regions with
the canonical set operators&amp;mdash;union ($\cup$) and intersection ($\cap$)&amp;mdash;they
form a &lt;a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice&lt;/a>. Lattices are another common algebraic structure, and we
will use results from both lattices and posets to develop our QE algorithm. Our
lattice has a global lower bound, the empty set ($\empty$), but because it is
infinite it has no global upper bound. As Niko&amp;rsquo;s posts explain, this global
lower bound corresponds to the special &lt;code>'static&lt;/code> lifetime in Rust.&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>&lt;/p>
&lt;p>The fundamental operation on these sets is the subset relation
($\sub$), which requires that the loans in one region also be present in
another. We are allowed to have many of these relations, all of
which must hold. This is logical conjunction ($\land$, sometimes abbreviated
with a comma).&lt;/p>
&lt;p>And&amp;hellip;That&amp;rsquo;s it! You can combine these operators to express, for example,
equality between regions ($a \sub b \land b \sub a \implies a = b$), but these
primitives are all that&amp;rsquo;s required to express most placeholder region
constraints. This is the logic we will extend with quantification.&lt;/p>
&lt;h2 id="existential-quantification">Existential quantification&lt;/h2>
&lt;p>With that out of the way, it&amp;rsquo;s time to add existential quantification ($\exists
x$) to the mix. I&amp;rsquo;ll use the approach from Lemma 2.4 in &lt;a href="http://cse.unl.edu/~revesz/papers/IJAC98.pdf">this paper by Peter
Revesz&lt;/a> to demonstrate an algorithm for QE. Revesz shows
quantifier elimination for a slightly more general theory,&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup> one
that allows for inequality constraints with the empty set, but we won&amp;rsquo;t need
that here. First, I&amp;rsquo;ll write a general form for all possible existentially
quantified formulas in our theory.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Here $y$, $z$, $u$, and $v$ are collections of region variables distinct from
the existentially quantified variable $x$ but not necessarily from each other.
$y$ is a series of lower bounds on $x$, $z$ is a series of upper bounds, and
$u$ and $v$ are unrelated constraints.&lt;/p>
&lt;p>Because $u$ and $v$ have no relation to $x$, we can move them outside of the
scope of the existential quantifier and ignore them for now. We&amp;rsquo;ll rewrite the
remaining constraints as a single upper and lower bound on $x$ using the
following lattice identities for sets:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>By applying these identities repeatedly to the lower and upper bounds, we can
express our existential quantifier as a single pair of subset constraints, one
on the union of the lower bounds and another on the intersection of the uppers.&lt;/p>
&lt;p>$$
\exists x (\bigcup\limits_{i=1}^{m} y_i \sub x, x \sub \bigcap\limits_{j=1}^{n} z_j)
$$&lt;/p>
&lt;p>If either $y$ or $z$ are empty&amp;mdash;i.e., there are no upper (or lower) bounds&amp;mdash;the
formula is trivially satisfiable by setting $x$ to the intersection of the
upper bounds or the union of the lower bounds respectively. Otherwise, we can
eliminate the quantified variable by applying the transitive property
of the subset operator ($(a \sub b) \land (b \sub c) \implies a \sub c$) and
then apply lattice identities $(1)$ and $(2)$ in reverse to get an equivalent
formula containing only subset constraints.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>We&amp;rsquo;ll add our unrelated constraints back in to get our final result, an
equivalent quantifier free formula for any existentially quantified one:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="universal-quantification">Universal quantification&lt;/h2>
&lt;p>If our theory had logical negation ($\neg$) as well as existential QE, we could
stop here. It would be straightforward to eliminate universal quantifiers
($\forall$) by using the following identity to transform them into existential
ones.&lt;/p>
&lt;p>$$
\forall x P(x) \implies \neg (\exists x \neg P(x))
$$&lt;/p>
&lt;p>Unfortunately, our theory does not permit logical negation. In fact, as I&amp;rsquo;ll
describe later, it cannot as long as we want QE. Luckily, due to the limits
we&amp;rsquo;ve imposed, we can construct a separate algorithm for eliminating universal
quantifiers. We will take the same approach as for existential quantifiers by
splitting the bounds on a quantified variable into upper and lower ones and
considering them separately.&lt;/p>
&lt;h3 id="upper-bounds">Upper bounds&lt;/h3>
&lt;p>Upper bounds on universally quantified variables are never satisfiable. For
example, if we have a constraint like $\forall x (x \sub z)$ for some free
region $z$, we can always find a loan $L$ such that $L \notin z$ because the
set of loans is infinite. The set $\{ L \} \cup z$ provides a counterexample
to our quantified formula, so any universally quantified formula with an upper
bound on the quantified variable is unsatisfiable ($\bot$).&lt;/p>
&lt;h3 id="lower-bounds">Lower bounds&lt;/h3>
&lt;p>Lower bounds, however, &lt;em>are&lt;/em> satisfiable due to the existence of a global lower
bound for regions. This is $\empty$ or, as we discussed earlier, &lt;code>'static&lt;/code>.
Given a constraint such as the following,&lt;/p>
&lt;p>$$\forall x (y \sub x)$$&lt;/p>
&lt;p>we can substitute $\empty$ for $x$ to obtain the constraint $y \sub \empty$ or
equivalently $y = \empty$. The resulting constraint is both necessary ($\empty$
is a valid region), and sufficient ($\forall x (\empty \sub x)$) for the
original formula to hold and is therefore equivalent.&lt;/p>
&lt;p>Universal quantification distributes over conjunction, so we can apply this
transformation across multiple constraints to obtain a universal QE algorithm for
conjunctions of subset constraints.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Remember, we only need to handle lower bounds on the existential: any upper
bound would make the entire formula unsatisfiable.&lt;/p>
&lt;h2 id="putting-it-all-together">Putting it all together&lt;/h2>
&lt;p>By repeatedly applying these QE algorithms to the innermost quantifier, we can
simplify arbitrarily complex quantified formulae to equivalent unquantified
ones, emit an error if any of them are unsatisfiable and pass the resulting
constraints to Polonius. Coupled with one of the approaches to emitting
placeholder region errors laid out on &lt;a href="https://smallcultfollowing.com/babysteps/blog/2019/01/17/polonius-and-region-errors/">Niko&amp;rsquo;s blog&lt;/a>, this
should be enough to handle any lifetime constraint that can be expressed in
Rust.&lt;/p>
&lt;p>Let&amp;rsquo;s try out a few test cases just to be sure. We&amp;rsquo;ll start with the example
&lt;code>forall&amp;lt;'x, 'y&amp;gt; { 'x: 'y }&lt;/code> from Niko&amp;rsquo;s blog. Our algorithm would show this to
be unsatisfiable by the following process:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>We begin by processing the innermost quantifier, which has $x$ as a lower bound
on the quantified variable $y$. This can be reduced to the constraint $x \sub
\empty$ via the algorithm for universal QE. But when we evaluate the second
quantifier, we see an upper bound on the quantified variable $x$, so this
formula is false.&lt;/p>
&lt;p>Another interesting example comes from &lt;a href="https://github.com/rust-lang/rust/pull/65232">rust-lang/rust#65232&lt;/a>:&lt;/p>
&lt;p>$$
\exists a \forall b (b \sub a) \implies \bot
$$&lt;/p>
&lt;p>The existing placeholder region logic needs a special-case to handle this type
of formula.&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup> This is because formulations of the borrow checker
based on program locations contain both a global upper bound (&lt;code>'static&lt;/code>, all
possible program locations) and a global lower bound (the &lt;a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_middle/ty/sty/enum.RegionKind.html#variant.ReEmpty">empty
region&lt;/a>). While the former is a valid solution to a constraint
problem, the latter results in an error. The process is more elegant in our new
system based on sets of loans, which does not have a global upper bound; the
innermost quantifier is trivially false.&lt;/p>
&lt;h2 id="negation-disjunction-and-implication">Negation, disjunction, and implication&lt;/h2>
&lt;p>It&amp;rsquo;s not all sunshine and roses, though. In the framework I&amp;rsquo;ve described above,
the presence of QE is mutually exclusive with logical negation.
Logical negation would allow us to express a &lt;strong>strict&lt;/strong> subset relation ($\neg
(b \sub a) \to a \subset b$), as well as inequality constraints between
arbitrary regions. To see why this is problematic, consider the following
formula.&lt;/p>
&lt;p>$$
\exists x (a \subset x \land x \subset b)
$$&lt;/p>
&lt;p>It may look like we can eliminate $x$ via the transitive property as we did
above, resulting in a similar constraint $a \subset b$. However, this does not
hold when $b$ has exactly one more element than $a$. There&amp;rsquo;s no &amp;ldquo;room&amp;rdquo; between
$a$ and $b$ to fit an extra element, so the formula is unsatisfiable in that
case. In reality, we would need an additional constraint on the cardinality of
$a$ and $b$:&lt;/p>
&lt;p>$$
\exists x (a \subset x \land x \subset b)
\implies (a \subset b) \land (|b| - |a| &amp;gt; 1)
$$&lt;/p>
&lt;p>Surprisingly, if we extend our theory with these so-called &amp;ldquo;cardinality
constraints&amp;rdquo;, it does have QE.&lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup> But these constraints, which have
no analogue in Rust, would leak into the borrow-checking parts of Polonius
where I have no idea how to handle them.&lt;/p>
&lt;p>Unfortunately, without negation we cannot have implication, one of
Niko&amp;rsquo;s hereditary Harrop clauses. Implication reduces to a combination of
negation and disjunction and would therefore require both of these extensions.&lt;/p>
&lt;p>$$
(P \to Q) \iff (\neg P \lor Q)
$$&lt;/p>
&lt;p>I&amp;rsquo;m somewhat more hopeful about incorporating disjunction ($\lor$) into
Polonius, although I&amp;rsquo;ve not made much effort in that direction. In the worst
case, we could allow it only outside of qualifiers, akin to unions of
conjunctive queries. It&amp;rsquo;s also possible that a QE algorithm exists that can
handle disjunction in any position.&lt;/p>
&lt;p>As far as I can tell, however, neither of these faculties are needed to express
the constraints available in current versions of Rust. Niko alludes to the fact
that richer constraints will be useful down the line, but perhaps the existence
of a simple QE algorithm outweighs this concern?&lt;/p>
&lt;h2 id="final-thoughts">Final thoughts&lt;/h2>
&lt;p>As I promised at the outset, the ideas I&amp;rsquo;ve presented here are all pretty simple.
None involve anything beyond basic set theory. In fact, I have a sneaking
suspicion that one or both of these QE algorithms were known to Niko when he
wrote the instigating blog post; the examples he chose enumerate our edge cases
with uncanny precision. If that&amp;rsquo;s true, I&amp;rsquo;m very curious to know why
he omitted them. Perhaps I&amp;rsquo;ve overlooked something?&lt;/p>
&lt;p>In any case, I&amp;rsquo;m hopeful that at least some of these ideas are new to the
Polonius team and can be used to formalize Rust&amp;rsquo;s placeholder region rules. If
not, perhaps the more formal treatment and parallels with Revesz&amp;rsquo;s work will
provide others with inspiration; I&amp;rsquo;d love to see Polonius move closer to
completion.&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>specifically &lt;a href="https://internals.rust-lang.org/t/blog-post-an-alias-based-formulation-of-the-borrow-checker/7411">IRLO&lt;/a> and &lt;code>#wg-polonius&lt;/code> on Zulip. &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>albeit in double exponential time via an algorithm known as &lt;a href="https://en.wikipedia.org/wiki/Cylindrical_algebraic_decomposition">cylindrical
algebraic decomposition&lt;/a>. &lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>There&amp;rsquo;s a fun proof of the cardinality of valid programs
in any general purpose programming language. If you accept that a program
exists that can output any natural number, then there are an infinite number
of valid programs. Furthermore, if you accept that all such programs can be
encoded as a binary string, the number of valid programs is countably
infinite. It does not necessarily follow that infinitely many programs means
infinitely many possible loans&amp;mdash;what is a loan anyways?&amp;mdash;but does strongly
suggest it. &lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>This was surprising to me, since I expected &lt;code>'static&lt;/code> to be
something like &amp;ldquo;the set of all possible loans&amp;rdquo;. When you start working
through the implications of constraints like &lt;code>'static: 'a&lt;/code> and &lt;code>'a: 'static&lt;/code>,
it becomes clear that &lt;code>'static&lt;/code> must be the empty set, but I still don&amp;rsquo;t have
an intuitive understanding of why &lt;code>'static&lt;/code> contains no loans. &lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>He refers to this class of logic as &amp;ldquo;Boolean order constraints&amp;rdquo;. You
can read more in Revesz&amp;rsquo;s textbook, &lt;a href="https://www.springer.com/gp/book/9780387987293">&lt;em>Introduction to Constraint Databases&lt;/em>&lt;/a>. &lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6" role="doc-endnote">
&lt;p>To be honest, I don&amp;rsquo;t know much about the current system, called
the &lt;a href="https://github.com/rust-lang/rust/issues/59490">leak check&lt;/a>. &lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:7" role="doc-endnote">
&lt;p>This result comes from &lt;a href="http://cse.unl.edu/~revesz/papers/ADBIS04.pdf">&amp;ldquo;Quantifier-Elimination for the
First-Order Theory of Boolean Algebras with Linear Cardinality
Constraints&amp;rdquo;&lt;/a>, another paper by Peter Revesz. &lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item></channel></rss>